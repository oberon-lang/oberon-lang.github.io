---
layout: post
title:  Motivation for a new Oberon version
author: Rochus Keller
---

This project started out as an [Oberon-07](http://www.projectoberon.net/wirth/Oberon/Oberon07.Report.pdf) parser, code model and transpiler written in C++ and Qt, with the goal to build tools to better understand the [Lola-2](https://www.inf.ethz.ch/personal/wirth/Lola/Lola2.pdf) compiler and to automatically translate it to maintainable C++ with minimal dependencies to other C++ libraries, and with no dependencies to the Oberon System (see the [Lola](https://github.com/rochus-keller/lola) and [LolaCreator](https://github.com/rochus-keller/lolacreator) repositories).

Oberon turned out to be a language very well suited for compiler front and backend experiments because it is decently simple but still powerful enough to build real-world software, as it supports pointers, static and stack based data structures and call by reference, which are not usually available with scripting languages. In consequence, a goal of this project was to study the feasibility of reusing [LuaJIT](http://luajit.org/) as a backend for statically typed programming languages like Oberon (see [this article](https://medium.com/@rochus.keller/implementing-call-by-reference-and-call-by-name-in-lua-47b9d1003cc2)), and to explore other VMs potentially suited as a backend. 

During my work with Oberon and systems implemented in Oberon, I kept asking myself what properties the language would need to have so that I could use it for my own systems too, without giving up the goal of making it as simple as possible. I - as likely many others - e.g. didn't like the capitalized keyword and basic type names, or the lack of enumerations. I also very much appreciate generic collections and algorithms and don't want to write these from scratch for every use case. For my taste, Oberon-07 is a very spartan language; it can evidentially be used to build systems, but in my view with too much effort and deprivation. With Oberon-2 things look much better, but the language still has the aforementioned inconveniences. Active Oberon is another option, but I don't like the syntax with the modifiers, and neither the break from the original principles of Oberon and Oberon-2. I find Component Pascal too complicated in the sense that in my view not so essential but rather complicated features were added, but e.g. generic programming, which I find essential for a "modern" software engineering, is still missing. But there are elements in all mentioned variants that I find very useful, e.g. delegates and inheritance from pointer to record types in Active Oberon, type bound procedures in Oberon-2 (which are also prominent in Go) and open arrays, or the flexible declaration sequences and string handling and specified type domains of Component Pascal.

From these considerations a new language emerged, which I call **Oberon+** (i.e. "Oberon with extensions", abbreviated OBX); it is based on Oberon-07, Oberon-2 and Oberon 90, with all the elements of these languages, plus the - from my point of view - most essential missing features and a lot of simplifications and increased flexibility. Oberon+ is - so to say - the Oberon I personally would have hoped for; from my point of view it represents modern simplicity in programming. 

New developers will probably enjoy the fact that the language looks quite similar to e.g. Lua, but offers static type safety and greater simplicity compared to other statically typed languages. Security-conscious developers will be pleased that there are pointers, but no pointer arithmetic, and every pointer is either nil or points to a valid object. Existing Oberon developers can continue to use the traditional syntax, which Oberon+ continues to support, and benefit selectively from the increased flexibility and new capabilities as needed. 


